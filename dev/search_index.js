var documenterSearchIndex = {"docs":
[{"location":"json/##-Serializing-Stock-and-Flow-Models.","page":"Serialization","title":"# Serializing Stock and Flow Models.","text":"","category":"section"},{"location":"json/","page":"Serialization","title":"Serialization","text":"using StockFlow\nusing Catlab\nusing Catlab.CategoricalAlgebra\nusing JSON3\nimport StockFlow: StockAndFlowpUntyped, vectorify, state_dict, add_stocks!, add_flow!, add_links!","category":"page"},{"location":"json/","page":"Serialization","title":"Serialization","text":"In order to serialize our models to JSON, we need to encode our functions as strings instead of julia functions. You can always recover the original model with Base.Meta.parse and eval.","category":"page"},{"location":"json/","page":"Serialization","title":"Serialization","text":"StockAndFlowSymbolic = StockAndFlowpUntyped{Symbol,String} \n\n# This is our constructor specialized to String formulas.\nNewStockAndFlowSymbolic(s,f) = begin\n\td = StockAndFlowSymbolic()\n\n    s = vectorify(s)\n    add_stocks!(d,length(s),sname=s)\n\n    s_idx = state_dict(s)\n    f = vectorify(f)\n    for (i, ((fattr,uds),ls)) in enumerate(f)\n      fn = first(fattr)\n      ff = last(fattr)\n    \tsui = s_idx[first(uds)]\n    \tsdi = s_idx[last(uds)]\n    \tls = vectorify(ls)\n    \tadd_flow!(d,sui,sdi,fname=fn,ϕf=ff)\n    \tadd_links!(d,map(x->s_idx[x],ls),repeat([i], length(ls)), length(ls))\n    end\n    d\nend","category":"page"},{"location":"json/#Examples","page":"Serialization","title":"Examples","text":"","category":"section"},{"location":"json/","page":"Serialization","title":"Serialization","text":"Our first example model is SIR.","category":"page"},{"location":"json/","page":"Serialization","title":"Serialization","text":"# define functions ϕ of flows in the SIR model\nfNewIncidence = \"p.cβ*u.S*u.I/p.N\"\nfNewRecovery = \"u.I/p.tr\"\n\n# StockAndFlowp(stocks,\n#               (flow=>function, upstream=>downstream) => stocks linked)\nsir = NewStockAndFlowSymbolic((:S, :I, :R), \n   ((:NewIncidence=>fNewIncidence, :S=>:I)=>(:S,:I),\n    (:NewRecovery=>fNewRecovery, :I=>:R)=>:I))\n","category":"page"},{"location":"json/","page":"Serialization","title":"Serialization","text":"@example JSON JSON3.pretty(generatejsonacset(sir))","category":"page"},{"location":"json/","page":"Serialization","title":"Serialization","text":"\nWe can include some of the premade models, which are found in the `PremadeModels` module. They are all full-bore Stock and Flows.\n","category":"page"},{"location":"json/","page":"Serialization","title":"Serialization","text":"@example JSON m = StockFlow.PremadeModels.seir_model","category":"page"},{"location":"json/","page":"Serialization","title":"Serialization","text":"","category":"page"},{"location":"json/","page":"Serialization","title":"Serialization","text":"@example JSON JSON3.pretty(generatejsonacset(m))","category":"page"},{"location":"json/","page":"Serialization","title":"Serialization","text":"\n## Schemas\n\nThe restricted class of primitive models.\n","category":"page"},{"location":"json/","page":"Serialization","title":"Serialization","text":"@example JSON JSON3.pretty(generatejsonacset_schema(TheoryStockAndFlowp))","category":"page"},{"location":"json/","page":"Serialization","title":"Serialization","text":"\nAnd for the generic schema\n","category":"page"},{"location":"json/","page":"Serialization","title":"Serialization","text":"@example JSON JSON3.pretty(generatejsonacset_schema(TheoryStockAndFlow)) ```","category":"page"},{"location":"#StockFlow","page":"StockFlow.jl","title":"StockFlow","text":"","category":"section"},{"location":"","page":"StockFlow.jl","title":"StockFlow.jl","text":"Modules = [\n    StockFlow,\n    StockFlow.Syntax,\n    StockFlow.PremadeModels\n]\nPrivate = false","category":"page"},{"location":"#StockFlow.TheoryStockAndFlow0","page":"StockFlow.jl","title":"StockFlow.TheoryStockAndFlow0","text":"define the sub-schema of c0, which includes the three objects: stocks(S), sum-auxiliary-variables(SV), and the linkages between them (LS) to be composed \n\n\n\n\n\n","category":"constant"},{"location":"#StockFlow.TheoryStockAndFlowF","page":"StockFlow.jl","title":"StockFlow.TheoryStockAndFlowF","text":"define the schema of a general stock and flow diagram \n\n\n\n\n\n","category":"constant"},{"location":"#StockFlow.TheoryStockAndFlowStructure","page":"StockFlow.jl","title":"StockFlow.TheoryStockAndFlowStructure","text":"define the schema of a general stock and flow diagram, not includes the functions of auxiliary variables \n\n\n\n\n\n","category":"constant"},{"location":"#StockFlow.TheoryStockAndFlowStructureF","page":"StockFlow.jl","title":"StockFlow.TheoryStockAndFlowStructureF","text":"define the schema of a general stock and flow diagram \n\n\n\n\n\n","category":"constant"},{"location":"#StockFlow.CausalLoop-Tuple{Any, Any}","page":"StockFlow.jl","title":"StockFlow.CausalLoop","text":"CausalLoop(ns,es)\n\nCreate causal loop diagram from collection of nodes and collection of edges.\n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.StockAndFlow0-Tuple{Any, Any, Any}","page":"StockFlow.jl","title":"StockFlow.StockAndFlow0","text":"StockAndFlow0(s,sv,ssv)\n\nfor an instance of the sub-schema, the program supports only have stocks, or only have sum auxiliary variables, or both stocks  and sum auxiliary variables, or have both \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.StockAndFlowF-NTuple{5, Any}","page":"StockFlow.jl","title":"StockFlow.StockAndFlowF","text":"StockAndFlowF(s,p,v,f,sv)\n\nEXAMPLE: when define the dynamical variables, need to define with the correct order\n\nsir_StockAndFlow=StockAndFlowF((:S=>(:F_NONE,:inf,:N), :I=>(:inf,:F_NONE,:N)),\n (:c, :beta),\n (:v_prevalence=>(:I,:N,:/),:v_meanInfectiousContactsPerS=>(:c,:v_prevalence,:*),:v_perSIncidenceRate=>(:beta,:v_meanInfectiousContactsPerS,:*),:v_newInfetions=>(:S,:v_perSIncidenceRate,:*)),\n (:inf=>:v_newInfetions),\n (:N))\n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.add_prefix!-Tuple{AbstractStockAndFlow0, Any}","page":"StockFlow.jl","title":"StockFlow.add_prefix!","text":"add_prefix!(sf::AbstractStockAndFlowStructureF, prefix)\n\nModify a AbstractStockAndFlowStructureF so named elements begin with prefix Prefix can be anything which can be cast to a Symbol.For feet.\n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.add_prefix!-Tuple{AbstractStockAndFlowStructureF, Any}","page":"StockFlow.jl","title":"StockFlow.add_prefix!","text":"add_prefix!(sf::AbstractStockAndFlowStructureF, prefix)\n\nModify a AbstractStockAndFlowStructureF so named elements begin with prefix Prefix can be anything which can be cast to a Symbol.\n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.add_suffix!-Tuple{AbstractStockAndFlow0, Any}","page":"StockFlow.jl","title":"StockFlow.add_suffix!","text":"add_suffix!(sf::AbstractStockAndFlow0, suffix)\n\nModify a AbstractStockAndFlow0 so named elements end with suffix. Suffix can be anything which can be cast to a Symbol. For feet.\n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.add_suffix!-Tuple{AbstractStockAndFlowStructureF, Any}","page":"StockFlow.jl","title":"StockFlow.add_suffix!","text":"add_suffix!(sf::AbstractStockAndFlow0, suffix)\n\nModify a AbstractStockAndFlow0 so named elements end with suffix. Suffix can be anything which can be cast to a Symbol.\n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.args-Tuple{AbstractStockAndFlowF, Any}","page":"StockFlow.jl","title":"StockFlow.args","text":"args(p::AbstractStockAndFlowF,v)\n\nReturn a Vector of Symbols of flattened stocks, sums, parameters and source dynamic variables a dynamic variable at index v links to.\n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.args-Tuple{AbstractStockAndFlowStructureF, Any}","page":"StockFlow.jl","title":"StockFlow.args","text":"args(p::AbstractStockAndFlowStructureF,v)\n\nReturn a Vector of Symbols of flattened stocks, sums, parameters and source dynamic variables a dynamic variable at index v links to.\n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.args_vname-Tuple{AbstractStockAndFlowStructureF, Any}","page":"StockFlow.jl","title":"StockFlow.args_vname","text":"Return a Tuple of Vectors of Symbols of flattened stocks, sums, parameters and source dynamic variables a dynamic variable at index v links to.\n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.convertStockFlowToSystemStructure-Tuple{AbstractStockAndFlowF}","page":"StockFlow.jl","title":"StockFlow.convertStockFlowToSystemStructure","text":"Return a new StockAndFlowStructureF with flattened names, operators and positions from an AbstractStockAndFlowF.\n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.convertSystemStructureToStockFlow-Tuple{AbstractStockAndFlowStructureF, Any}","page":"StockFlow.jl","title":"StockFlow.convertSystemStructureToStockFlow","text":"Return a new stock flow with flattened names, operators and positions from an AbstractStockAndFlowStructureF. Need to provide dynamic variable definitions, eg\n\nconvertSystemStructureToStockFlow(MyStockFlowStructure, (:v_prevalence=>(:I,:N,:/),:v_meanInfectiousContactsPerS=>(:c,:v_prevalence,:*)))\n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.convertToCausalLoop-Tuple{AbstractStockAndFlowStructureF}","page":"StockFlow.jl","title":"StockFlow.convertToCausalLoop","text":"Convert StockFlow to CLD. Nodes: stocks, flows, sum variables, parameters, nonflow dynamic variables Edges: morphisms in stock flow\n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.extracFlowsStructureAndFlatten-Tuple{AbstractStockAndFlowStructure}","page":"StockFlow.jl","title":"StockFlow.extracFlowsStructureAndFlatten","text":"Return flow names as Symbol, along with the linked flow variables\n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.extracPsStructureAndFlatten-Tuple{AbstractStockAndFlowStructureF}","page":"StockFlow.jl","title":"StockFlow.extracPsStructureAndFlatten","text":"Return parameter names as Symbol\n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.extracStocksStructureAndFlatten-Tuple{AbstractStockAndFlowStructureF}","page":"StockFlow.jl","title":"StockFlow.extracStocksStructureAndFlatten","text":"Return stock names as Symbol, along with the linked flows and sum variables\n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.extracSumVStructureAndFlatten-Tuple{AbstractStockAndFlowStructureF}","page":"StockFlow.jl","title":"StockFlow.extracSumVStructureAndFlatten","text":"Return sum variable names as Symbol, along with the linked dynamic variables\n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.extracVAndAttrStructureAndFlatten-Tuple{AbstractStockAndFlowF}","page":"StockFlow.jl","title":"StockFlow.extracVAndAttrStructureAndFlatten","text":"Convert dynamic variable names to Symbol, convert all operators to a single operator if they are equal else throw an error, and  \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.extracVStructureAndFlatten-Tuple{AbstractStockAndFlowStructureF}","page":"StockFlow.jl","title":"StockFlow.extracVStructureAndFlatten","text":"Return dynamic variable definitions as Vector with elements of form :dv => [:arg1, :arg2]\n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.flowVariableIndex-Tuple{AbstractStockAndFlowStructure, Any}","page":"StockFlow.jl","title":"StockFlow.flowVariableIndex","text":"return the auxiliary variable's index that related to the flow with index of f \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.fname-Tuple{AbstractStockAndFlowStructure, Any}","page":"StockFlow.jl","title":"StockFlow.fname","text":"return the flows name with index of f \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.fnames-Tuple{AbstractStockAndFlowStructure}","page":"StockFlow.jl","title":"StockFlow.fnames","text":"return flow names \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.funcDynam-Tuple{AbstractStockAndFlow, Any}","page":"StockFlow.jl","title":"StockFlow.funcDynam","text":"funcDynam(p::AbstractStockAndFlow,v)\n\nreturn the functions of variables give index v \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.funcDynam-Tuple{AbstractStockAndFlowF, Any}","page":"StockFlow.jl","title":"StockFlow.funcDynam","text":"funcDynam(sf::AbstractStockAndFlowF,v)\n\nreturn the functions of variables give index v \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.funcFlow-Tuple{Union{AbstractStockAndFlow, AbstractStockAndFlowF}, Any}","page":"StockFlow.jl","title":"StockFlow.funcFlow","text":"generate the function substituting sum variables in with flow index fn \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.funcFlowRaw-Tuple{Union{AbstractStockAndFlow, AbstractStockAndFlowF}, Any}","page":"StockFlow.jl","title":"StockFlow.funcFlowRaw","text":"return the functions (not substitutes the function of sum variables yet) of flow index f \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.funcFlows-Tuple{Union{AbstractStockAndFlow, AbstractStockAndFlowF}}","page":"StockFlow.jl","title":"StockFlow.funcFlows","text":"return the LVector of pairs: fname => function (with function of sum variables substitue in) \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.funcFlowsRaw-Tuple{Union{AbstractStockAndFlow, AbstractStockAndFlowF}}","page":"StockFlow.jl","title":"StockFlow.funcFlowsRaw","text":"return the LVector of pairs: fname => function (raw: not substitutes the function of sum variables yet) \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.funcSV-Tuple{AbstractStockAndFlow0, Any}","page":"StockFlow.jl","title":"StockFlow.funcSV","text":"generate the function of a sum auxiliary variable (index sv) with the sum of all stocks links to it \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.funcSVs-Tuple{AbstractStockAndFlow0}","page":"StockFlow.jl","title":"StockFlow.funcSVs","text":"return the LVector of pairs: svname => function \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.fv-Tuple{AbstractStockAndFlowStructure, Any}","page":"StockFlow.jl","title":"StockFlow.fv","text":"get flow variable of flow \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.fvs-Tuple{AbstractStockAndFlowStructure}","page":"StockFlow.jl","title":"StockFlow.fvs","text":"get ordered list of indices of dynamic variable for each flow \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.inflows-Tuple{AbstractStockAndFlowStructure, Any}","page":"StockFlow.jl","title":"StockFlow.inflows","text":"return inflows of stock index s \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.inflowsAll-Tuple{AbstractStockAndFlowStructure}","page":"StockFlow.jl","title":"StockFlow.inflowsAll","text":"return all inflows \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.instock-Tuple{AbstractStockAndFlowStructure, Any}","page":"StockFlow.jl","title":"StockFlow.instock","text":"return stocks of flow index f flow in \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.lpvvposition-Tuple{AbstractStockAndFlowF, Any}","page":"StockFlow.jl","title":"StockFlow.lpvvposition","text":"return argument position of source constant parameter of an auxiliary variable \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.lsnames-Tuple{AbstractStockAndFlow0}","page":"StockFlow.jl","title":"StockFlow.lsnames","text":"return the pair of names of (stock, sum-auxiliary-variable) for all linkages between them \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.lsvvposition-Tuple{AbstractStockAndFlowF, Any}","page":"StockFlow.jl","title":"StockFlow.lsvvposition","text":"return argument position of source sum dynamical variable of an auxiliary variable \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.lvtgtposition-Tuple{AbstractStockAndFlowF, Any}","page":"StockFlow.jl","title":"StockFlow.lvtgtposition","text":"return argument position of source auxiliary variable of an auxiliary variable \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.lvvposition-Tuple{AbstractStockAndFlowF, Any}","page":"StockFlow.jl","title":"StockFlow.lvvposition","text":"return argument position of source stock variable of an auxiliary variable \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.make_v_expr-Tuple{AbstractStockAndFlowF, Any}","page":"StockFlow.jl","title":"StockFlow.make_v_expr","text":"create expresision of an auxiliary variable v \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.ne-Tuple{AbstractCausalLoop}","page":"StockFlow.jl","title":"StockFlow.ne","text":"return count of edges of CLD \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.nf-Tuple{AbstractStockAndFlowStructure}","page":"StockFlow.jl","title":"StockFlow.nf","text":"flow count \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.ni-Tuple{AbstractStockAndFlowStructure}","page":"StockFlow.jl","title":"StockFlow.ni","text":"inflow count \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.nlpv-Tuple{AbstractStockAndFlowStructureF}","page":"StockFlow.jl","title":"StockFlow.nlpv","text":"link dynamic variable parameter count \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.nls-Tuple{AbstractStockAndFlow0}","page":"StockFlow.jl","title":"StockFlow.nls","text":"link stock sum count \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.nlsv-Tuple{AbstractStockAndFlowStructure}","page":"StockFlow.jl","title":"StockFlow.nlsv","text":"link sum variable dynamic variable count \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.nlv-Tuple{AbstractStockAndFlowStructure}","page":"StockFlow.jl","title":"StockFlow.nlv","text":"link stock dynamic variable count \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.nlvv-Tuple{AbstractStockAndFlowStructureF}","page":"StockFlow.jl","title":"StockFlow.nlvv","text":"link dynamic variable dynamic variable count \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.nn-Tuple{AbstractCausalLoop}","page":"StockFlow.jl","title":"StockFlow.nn","text":"return count of nodes of CLD \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.nname-Tuple{AbstractCausalLoop, Any}","page":"StockFlow.jl","title":"StockFlow.nname","text":"return node's name with index n \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.nnames-Tuple{AbstractCausalLoop}","page":"StockFlow.jl","title":"StockFlow.nnames","text":"return node names of CLD \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.no-Tuple{AbstractStockAndFlowStructure}","page":"StockFlow.jl","title":"StockFlow.no","text":"outflow count \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.np-Tuple{AbstractStockAndFlowStructureF}","page":"StockFlow.jl","title":"StockFlow.np","text":"parameter count \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.ns-Tuple{AbstractStockAndFlow0}","page":"StockFlow.jl","title":"StockFlow.ns","text":"stock count \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.nsv-Tuple{AbstractStockAndFlow0}","page":"StockFlow.jl","title":"StockFlow.nsv","text":"sum variable count \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.nvb-Tuple{AbstractStockAndFlowStructure}","page":"StockFlow.jl","title":"StockFlow.nvb","text":"dynamic variable count \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.outflows-Tuple{AbstractStockAndFlowStructure, Any}","page":"StockFlow.jl","title":"StockFlow.outflows","text":"return outflows of stock index s \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.outflowsAll-Tuple{AbstractStockAndFlowStructure}","page":"StockFlow.jl","title":"StockFlow.outflowsAll","text":"return all outflows \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.outstock-Tuple{AbstractStockAndFlowStructure, Any}","page":"StockFlow.jl","title":"StockFlow.outstock","text":"return stocks that flow index f flow out from \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.pname-Tuple{AbstractStockAndFlowStructureF, Any}","page":"StockFlow.jl","title":"StockFlow.pname","text":"return the auxiliary variables name with index of v \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.pnames-Tuple{AbstractStockAndFlowStructureF}","page":"StockFlow.jl","title":"StockFlow.pnames","text":"return parameter names \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.rebuildStratifiedModelByFlattenSymbols-Tuple{AbstractStockAndFlowF}","page":"StockFlow.jl","title":"StockFlow.rebuildStratifiedModelByFlattenSymbols","text":"Return a new stock flow with flattened names, operators and positions from the old\n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.sedge-Tuple{AbstractCausalLoop, Any}","page":"StockFlow.jl","title":"StockFlow.sedge","text":"return edge's name with target number t \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.set_fnames!-Tuple{AbstractStockAndFlowStructure, Any}","page":"StockFlow.jl","title":"StockFlow.set_fnames!","text":"set flow names to vector of symbols\n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.set_pnames!-Tuple{AbstractStockAndFlowStructure, Any}","page":"StockFlow.jl","title":"StockFlow.set_pnames!","text":"set parameter names to vector of symbols\n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.set_snames!-Tuple{AbstractStockAndFlow0, Any}","page":"StockFlow.jl","title":"StockFlow.set_snames!","text":"set stock names to vector of symbols\n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.set_svnames!-Tuple{AbstractStockAndFlow0, Any}","page":"StockFlow.jl","title":"StockFlow.set_svnames!","text":"set sum variable names to vector of symbols\n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.set_vnames!-Tuple{AbstractStockAndFlowStructure, Any}","page":"StockFlow.jl","title":"StockFlow.set_vnames!","text":"set dynamic variable names to vector of symbols\n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.sname-Tuple{AbstractStockAndFlow0, Any}","page":"StockFlow.jl","title":"StockFlow.sname","text":"return the stocks name with index of s \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.snames-Tuple{AbstractStockAndFlow0}","page":"StockFlow.jl","title":"StockFlow.snames","text":"return stock names \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.stockssv-Tuple{AbstractStockAndFlow0, Any}","page":"StockFlow.jl","title":"StockFlow.stockssv","text":"return stocks that sum variable index sv link to \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.stocksv-Tuple{AbstractStockAndFlowStructure, Any}","page":"StockFlow.jl","title":"StockFlow.stocksv","text":"return stocks that auxiliary variable index v link to \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.svname-Tuple{AbstractStockAndFlow0, Any}","page":"StockFlow.jl","title":"StockFlow.svname","text":"return the sum auxiliary variables name with index of sv \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.svnames-Tuple{AbstractStockAndFlow0}","page":"StockFlow.jl","title":"StockFlow.svnames","text":"return sum variable names \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.svsstock-Tuple{AbstractStockAndFlowStructure, Any}","page":"StockFlow.jl","title":"StockFlow.svsstock","text":"return sum auxiliary variables that stock s links to \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.svsstockAllF-Tuple{AbstractStockAndFlowStructure}","page":"StockFlow.jl","title":"StockFlow.svsstockAllF","text":"return sum auxiliary variables all stocks link (frequency) \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.svsv-Tuple{AbstractStockAndFlowStructure, Any}","page":"StockFlow.jl","title":"StockFlow.svsv","text":"return sum variables that auxiliary variable index v link to \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.tedge-Tuple{AbstractCausalLoop, Any}","page":"StockFlow.jl","title":"StockFlow.tedge","text":"return edge's name with edge number e \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.vname-Tuple{AbstractStockAndFlowStructure, Any}","page":"StockFlow.jl","title":"StockFlow.vname","text":"return the auxiliary variables name with index of v \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.vnames-Tuple{AbstractStockAndFlowStructure}","page":"StockFlow.jl","title":"StockFlow.vnames","text":"return variable names \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.vop-Tuple{AbstractStockAndFlowF, Any}","page":"StockFlow.jl","title":"StockFlow.vop","text":"return operator of an auxiliary variable \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.vpsrc-Tuple{AbstractStockAndFlowStructureF, Any}","page":"StockFlow.jl","title":"StockFlow.vpsrc","text":"return auxiliary variable's source constant parameters \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.vptgt-Tuple{AbstractStockAndFlowStructureF, Any}","page":"StockFlow.jl","title":"StockFlow.vptgt","text":"return constant parameters's link auxiliary variables \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.vsrc-Tuple{AbstractStockAndFlowStructureF, Any}","page":"StockFlow.jl","title":"StockFlow.vsrc","text":"return auxiliary variable's target auxiliary variables it links to \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.vsstock-Tuple{AbstractStockAndFlowStructure, Any}","page":"StockFlow.jl","title":"StockFlow.vsstock","text":"return auxiliary variables that stock s links to \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.vsstockAllF-Tuple{AbstractStockAndFlowStructure}","page":"StockFlow.jl","title":"StockFlow.vsstockAllF","text":"return auxiliary variables all stocks link (frequency) \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.vssv-Tuple{AbstractStockAndFlowStructure, Any}","page":"StockFlow.jl","title":"StockFlow.vssv","text":"return auxiliary variables that sum auxiliary variable sv links to \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.vssvAllF-Tuple{AbstractStockAndFlowStructure}","page":"StockFlow.jl","title":"StockFlow.vssvAllF","text":"return auxiliary variables all sum auxiliary variables link (frequency) \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.vtgt-Tuple{AbstractStockAndFlowStructureF, Any}","page":"StockFlow.jl","title":"StockFlow.vtgt","text":"return auxiliary variable's source auxiliary variables that it links to \n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.Syntax","page":"StockFlow.jl","title":"StockFlow.Syntax","text":"Alternative syntax for use in the definition of stock and flow models.\n\nExamples\n\n# An S-I-R model of infection\nSIR = @stock_and_flow begin\n    :stocks\n    S\n    I\n    R\n\n    :parameters\n    c\n    beta\n    tRec\n\n    :dynamic_variables\n    v_prevalence = I / N\n    v_meanInfectiousContactsPerS = c * v_prevalence\n    v_perSIncidenceRate = beta * v_meanInfectiousContactsPerS\n    v_newInfections = S * v_perSIncidenceRate\n    v_newRecovery = I / tRec\n\n    :flows\n    S => inf(v_newInfections) => I\n    I => rec(v_newRecovery) => R\n\n    :sums\n    N = [S, I, R]\nend\n\n# Generates:\n# SIR = StockAndFlowF(\n#     # stocks\n#     (:S => (:F_NONE, :inf, :N), :I => (:inf, :rec, :N), :R => (:rec, :F_NONE, :N)),\n#     # parameters\n#     (:c, :beta, :tRec),\n#     # dynamical variables\n#     (   :v_prevalence => ((:I, :N) => :/),\n#         :v_meanInfectiousContactsPerS => ((:c, :v_prevalence) => :*),\n#         :v_perSIncidenceRate => ((:beta, :v_meanInfectiousContactsPerS) => :*),\n#         :v_newInfections => ((:S, :v_perSIncidenceRate) => :*),\n#         :v_newRecovery => ((:I, :tRec) => :/),\n#     ),\n#     # flows\n#     (:inf => :v_newInfections, :rec => :v_newRecovery),\n#     # sum dynamical variables\n#     (:N),\n# )\n\n# The same model as before, but with the dynamic variables inferred\nSIR_2 = @stock_and_flow begin\n    :stocks\n    S\n    I\n    R\n\n    :parameters\n    c\n    beta\n    tRec\n\n    # We can leave out dynamic variables and let them be inferred from flows entirely!\n\n    :flows\n    S => inf(S * beta * (c * (I / N))) => I\n    I => rec(I / tRec) => R\n\n    :sums\n    N = [S, I, R]\nend\n\n# Another possible S-I-R model definition\nSIR_3 = @stock_and_flow begin\n    :stocks\n    S\n    I\n    R\n\n    :parameters\n    c\n    beta\n    tRec\n    omega\n    alpha\n\n    :dynamic_variables\n    v_prevalence = I / totalPopulation\n    v_forceOfInfection = c * v_prevalence * beta\n\n    :flows\n    S => inf(S * v_forceOfInfection) => I\n    ☁ => births(totalPopulation * alpha) => S\n    S => deathsS(S * omega) => ☁\n    I => rec(I / tRec) => R\n    I => deathsI(I * omega) => ☁\n    R => deathsR(R * omega) => ☁\n\n\n    :sums\n    totalPopulation = [S, I, R]\nend\n\n\n\n\n\n","category":"module"},{"location":"#StockFlow.Syntax.infer_links-Tuple{StockAndFlowF, StockAndFlowF, Dict{Symbol, Vector{Int64}}}","page":"StockFlow.jl","title":"StockFlow.Syntax.infer_links","text":"infer_links(sfsrc :: StockAndFlowF, sftgt :: StockAndFlowF, NecMaps :: Dict{Symbol, Vector{Int64}})\n\nInfer LS, I, O, LV, LSV, LVV, LPV mappings for an ACSetTransformation. Returns dictionary of Symbols to lists of indices, corresponding to an ACSetTransformation argument. If there exist no such mappings (eg, no LVV), that pairing will not be included in the returned dictionary.\n\nIf A <- C -> B, and we have A -> A' and B -> B' and a unique C' such that A' <- C' -> B', we can assume C -> C'.\n\n:S => [2,4,1,3], :F => [1,2,4,3], ...\n\nNecMaps must contain keys S, F, SV, P, V, each pointing to a (possibly empty) array of indices\n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.Syntax.@feet-Tuple{Expr}","page":"StockFlow.jl","title":"StockFlow.Syntax.@feet","text":"feet(block :: Expr)\n\nCreate Vector of feet using same notation for foot macro. Separated by newlines. First argument is stock, second is sum variable.\n\nfeetses = @feet begin\n    A => B\n    () => N\n    C => ()\n    D => E\n    () => ()\n    P => NI, R => NI, () => N\nend\n\n\n\n\n\n","category":"macro"},{"location":"#StockFlow.Syntax.@foot-Tuple{Expr}","page":"StockFlow.jl","title":"StockFlow.Syntax.@foot","text":"foot(block :: Expr)\n\nCreate a foot with S => N syntax, where S is stock, N is sum variable.\n\n@foot P => Q\n@foot S1 => ()\n@foot () => N\n@foot () => ()\n@foot A => N, () => NI\n\n\n\n\n\n","category":"macro"},{"location":"#StockFlow.Syntax.@stock_and_flow-Tuple{Any}","page":"StockFlow.jl","title":"StockFlow.Syntax.@stock_and_flow","text":"stock_and_flow(block :: Expr)\n\nCompiles stock and flow syntax of the line-based block form\n\n  :stocks\n    symbol_1\n    symbol_2\n    ...\n    symbol_n\n\n  :parameters\n    param_1\n    param_2\n    ...\n    param_n\n\n  :dynamic_variables\n    dyvar_1 = symbol_h * param_g ... - symbol_x / param_y\n    ...\n    dyvar_n = symbol_k * param_j - dyvar_a ... - symbol_p / param_q\n\n  :flows\n    symbol_r => flow_name_1(dyvar_k) => symbol_q\n    symbol_z => flow_name_2(dyvar_g * param_v) => symbol_p\n    ☁       => flow_name_3(symbol_c + dyvar_b) => symbol_r\n    symbol_j => flow_name_4(param_l + symbol_m) => CLOUD\n    ...\n    symbol_y => flow_name_n(dyvar_f) => ☁\n\ninto a StockAndFlowF data type for use with the StockFlow.jl modelling system.\n\n\n\n\n\n","category":"macro"},{"location":"#StockFlow.PremadeModels.seir-Tuple{}","page":"StockFlow.jl","title":"StockFlow.PremadeModels.seir","text":"Return a new SEIR model\n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.PremadeModels.sir-Tuple{}","page":"StockFlow.jl","title":"StockFlow.PremadeModels.sir","text":"Return a new SIR model\n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.PremadeModels.sis-Tuple{}","page":"StockFlow.jl","title":"StockFlow.PremadeModels.sis","text":"Return a new SIS model\n\n\n\n\n\n","category":"method"},{"location":"#StockFlow.PremadeModels.svi-Tuple{}","page":"StockFlow.jl","title":"StockFlow.PremadeModels.svi","text":"Return a new SVI model\n\n\n\n\n\n","category":"method"}]
}
